# 什么是MVCC 

- 事务在`并发环境`下会带来脏读、脏写、不可重复读等诸多问题
- **为了解决这些问题，保证事务的ACID四大特性**，出现了诸多`隔离级别`去解决这些问题
- MySQL默认采用的隔离级别是可重复读。
- 那么MySQL是怎么划分出4个隔离级别的？
- 答案是通过MVCC（Multi-Version Concurrency Control）机制。

> 多版本并发控制：是一种利用版本号来控制事务读取数据的

- 它类似于的CAS、AQS这类乐观锁机制
- 主要是利用`undolog`和`read view`来控制实现
- 这里面就不细致讲了,主要是着实难讲清楚,想了解的去b站看视频画图讲解会好很多

`undolog` -> 撤销日志,这个日志文件会保存历史数据记录

`read view` -> 快照读,执行一次sql后会更新一个快照信息,这个信息里保存了这一时刻还未提交的事务信息

原理: 快照中的事务与日志中的历史记录做判断,拿出符合条件的历史记录

> RC: 读已提交 -> 意思就是日志中的历史记录与快照事务做比对的时候只取最近提交的那一次记录

- RC**第一次读,拿到一次read view**,对比最近提交的那一次日志记录返回SELECT查询
- **RC第二次读,再重新获取一次新的 read view**,对比最近提交的那一次记录返回SELECT查询
- 这两次读的结果,都只会取**最近提交完成的那一次记录**,不会读到未提交的数据,不会有脏读
  - 但是第二次读的时候,可能有事务又提交了,那么**新的read view里面就会排除掉提交的事务信息**
  - read view只会保留还未提交的事务,就与第一次的 read view不同了
  - 那么最后日志与 read view的结果就**取了最新的提交,就发现2次读出现了不一样的结果叫不可重复读**

> RR: 可重复读,**为了解决RC的不可重复读的问题,RR想了一个办法**

- 读2次获取的read view不一样导致结果不一样了
- 那么**我就读一次read view,第二次不在更新新的read view了,就用原来的**
- 那么**最后与日志比对,数据一定会返回第一次一模一样的**
  - `这里面是判断了,一个if判断,有好几个条件,最后就是会满足这样的结果`
  - 要是纠结它是这么做判断了,搜搜b站的视频,结果就是这样的,就是为了这样的结果来规定if判断的
- 最后RR解决了不可重复读的问题,两次读一定是一样的历史数据

> 通过ReadView⽣成策略的不同实现不同的隔离级别。